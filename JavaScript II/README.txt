Это комментарий к тому "JavaScript II".

Следует прокомментировать следующие темы.
Прокси.
Язык все же различает прокси- объекты и их целевые объекты - ловушки вызываются только тогда, когда происходит обращение к прокси- объекту.
Прокси- объекты до сих пор проблематично поддерживаются реализациями языка. Их возможности следует уточнять для конкретного интерпретатора.
Будучи созданы, прокси- объекты не могут быть отлючены от целевого объекта. Однако, есть специфическое средство, позволяющее обойти это ограничение. Это метод Proxy.revocable() - конструктор отключаемых прокси- объектов (принимает те же параметры, возвращает отключаемый прокси- объект). Отключение такого прокси- объекта производится его методом ObjectName.revoke().
Модули.
Модуль - это файл сценария, подключаемый как модуль (<sript type="module">). В настоящее время сценарии всегда подключают из отдельного файла; кроме того, сама концепция модуля подразумевает, чтобы код модуля располагался в отдельном предназначенном для него файле.
Будучи подключен к сценарию, модуль исполняется. Подключается он как и любой элемент <script>. Код самого модуля исполняется всегда в строгом режиме.
Модуль создает область видимости - он не доступен из глобальной области видимости, но имеет доступ к ней. У функций, определенных непосредстенно в модуле, this = undefinied. Это все особенности исполнения кода модуля.
Модуль может экспортировать имена. Чтобы экспортировать имя, прибегают к соответствующей записи (export ... ; // ... - запись объявления имени); экспортировать можно класс, функцию и переменную этд. Запись экспорта может быть и после объявления имени - эта возможность предусмотрена для того, чтобы экспортировать было и переменную, используемую как ссылку (тогда запись принимает вид export VarName;).
Экспортирование имен приводит к тому, что они становятся доступны для импорта.
Импорт делает доступными импортированные имена. Импортирвание имен из экспортирующего их модуля производится соответствующей записью (import {VarName0, ... , VarNameN} from " ... "; // " ... " это путь к модулю, путь задается в обычном для HTML виде). Импортированные имена становятся доступны (в импортирующем модуле) для использования как константы (строго говоря, как объявленные со спецификатором const).
Можно импортировать и сразу все экспортируемые имена, соответствующей записью (import * as ObjectName from " ... ";). Тогда все экспортируемые имена будут доступны как члены объекта ObjectName, сам этот объект будет создан интерпретатором .
Экспортировать/импортировать имена можно и под целевыми именами. Для этого служат соответствующие записи; для экспорта (export {VarName as NewVarName};), и после применения этой записи импорт становится возможен только под целевым именем; для импорта (import {VarName as NewVarName} from " ... ";) - и тогда импортированное имя будет доступно только под целевым именем.
Имеется также специфическая возможность - экспорт/импорт по умолчанию. Экспортировать/импортировать по умолчанию возможно только одно значение (как обычно, это класс, функция, переменная этд). Это предусмотрено для того, чтобы передавать по умолчанию лишь одно значение (если бы по умолчанию можно было передать целый ряд значений, то это бы усложняло механизм передачи по умолчанию - по мнению разработчиков языка).
Для этой возможности предусмотрены соответствующие записи. Для экспорта (export default ... ; // ... - экспортируемое объявление, или же записью после объявления - export default VarName;), экспортировать можно и под целевым именем (export {VarName as default};).
Для импорта (import VarName from " ... ";); если импорт по умолчанию в одной записи с обычным импортом (import DefaultVarName {VarName, ... } from " ... ";); если при этом импорт по умолчанию с целевым именем (import {DefaultVarName as NewVarName, VarName, ... } from " ... ";).
Имеется возможность объявить импортируемое экспортируемым (возможность реэкспорта). Эту возможность можно использовать и в специфической записи (export {VarName, ... } from " ... ";) - причем, можно экспортировать и под целевым именем, и экспортировать все импортированное (как обычно, в записи *).
Записи экспорта и импорта должны располагаться непосредственно в коде сценария (вне функций, и операторов управления ходом вычислений).
Реализацию возможностей импорта/экспорта необходимо уточнять для каждого конкретного интерпретатора.
Методы описываются по следующей схеме:
в начале описывается цель, с которой предполагается применять эту функцию (действительно, это лучшее вступление в описание функции),
затем описываются принимаемые параметры (действительно, необходимо знать, какие параметры может принимать функция),
затем описывается логика функции (действительно, необходимо знать, что именно делает функция в зависимости от принятых параметров),
затем описывается возвращаемое функцией значение (действительно, необходимо знать, что возвращает функция),
и затем даются прочие комментарии к описываемой функции (если к описанию функции можно дать существенные дополнения).
Я полагаю, такая схема описания встроенных функций позволит однозначно понимать, как использовать ту или иную функцию корректно.
Прочих комментариев этот том не требует.